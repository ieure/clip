#+AUTHOR: Ian Eure <ian@retrospec.tv>
#+TITLE: Common Lisp in Practice
#+OPTIONS: num:nil p:nil

* Introduction

  One of the things which has kept Common Lisp out of my day-to-day
  toolbox is a lack of clear instructions how to get up and running
  with it — not in the REPL, but building smaller utility programs
  that can be called from the shell.  I tend to reach for Python or
  Emacs Lisp, since they’re readily available and I understand them,
  but I’ve always felt that Common Lisp could be a potent tool as
  well.

  Building a project in Lisp can be confusing, because Lisp itself
  works so differently to other languages, and this affects how builds
  work.  While Lisp compiles to machine code like many languages, the
  mechanisms are very different.

  After reading my friend Steve’s [[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][Road to Common Lisp]], I was inspired
  to figure this out.  With some patient help from him, I believe I’ve
  finally got a handle on it.


* Goals

  The overarching goal is to explain /how/ to put together a Common
  Lisp Program, by walking through it, leaving a working,
  well-understood system at the end.

  It isn’t a tutorial on Lisp programming, because there are already
  [[http://www.gigamonkeys.com/book/][great resources]] [[http://www.paulgraham.com/onlisp.html][for that]].

  It won’t rathole on every possible approach you could possibly use,
  but treads and illuminates the beaten path.  It will explain the
  non-obvious nuts-and-bolts of building Common Lisp programs: Where
  to put source code, how to make a binary, how to use libraries.


* Running

  If you’d like to run the example code, you’ll need to install [[http://www.sbcl.org/][Steel
  Bank Common Lisp (SBCL)]] and [[https://www.quicklisp.org/][Quicklisp]].  The Quicklisp installation
  is unusual if you’re coming from other languages, so it’s also fine
  to read along and see what things are like before investing in a
  Lisp environment.

  I wrote this in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style using [[https://orgmode.org/manual/Working-with-source-code.html#Working-with-source-code][org-babel]].  All
  program output should be very, very close to what you’d see if you
  ran those programs.  The [[https://github.com/ieure/clip/blob/source/source.org][original Org document]] and [[https://github.com/ieure/cl-hello/tree/output/][source code
  extracted from it]] are available in [[https://github.com/ieure/clip/tree/master][my GitHub repo]].


* Background

  A typical compiler forks a new OS process for each file, producing a
  binary artifact corresponding to its input; then a linker combines
  those into the final binary.  Each binary in this process represents
  a capability boundary.  The compiler, linker, and other tools can’t
  be embedded in your own programs.

  Another way of explaining this is that most languages have a 1:1
  relationship between /programs/ and /binaries/.

  Common Lisp does not work this way.  In Lisp, /everything/ is loaded
  into the same environment, and all functionality is accessible in
  the same way — by calling a function.  The result is a much more
  comprehensive and tightly integrated system than other languages.

  This is an important point to understand.  Most languages lock up
  significant amounts of their functionality in separate binaries, and
  only allow you to access them from the shell — not from your own
  programs.  Lisp exposes its full power in a consistent way.

  For example, Python 3 ships with five binaries:

  #+BEGIN_SRC shell :exports both
  dpkg -L python3-minimal | grep -c /bin/
  #+END_SRC

  #+RESULTS:
  : 5

  The binaries include the interpreter, a byte-compiler, another
  program to remove the files the byte-compiler creates, etc.

  OpenJDK has 21:

  #+BEGIN_SRC shell :exports both
  dpkg -L openjdk-8-jre-headless | grep -c /bin/
  #+END_SRC

  #+RESULTS:
  : 21

  GCC has 16:

  #+BEGIN_SRC shell :exports both
  dpkg -L gcc | grep -c /bin/
  #+END_SRC

  #+RESULTS:
  : 16

  And in order to actually /use/ GCC, you also need binutils, which
  has nearly 40 more:

  #+BEGIN_SRC shell :exports both
  dpkg -L binutils | grep -c /bin/
  #+END_SRC

  #+RESULTS:
  : 37

  Can you guess how many Steel Bank Common Lisp (SBCL) has?

  #+BEGIN_SRC shell :exports both
  dpkg -L sbcl | grep -c /bin/
  #+END_SRC

  #+RESULTS:
  : 1

  Just one, =/usr/bin/sbcl=.  Everything that can be done with SBCL is
  done with this one binary and environment it provides.


** The Environment; Images

   When Common Lisp starts, it initializes a *Lisp environment* in the
   computer’s memory, then evaluates a *toplevel function*.  The
   environment contains the Lisp language and tools; the standard
   toplevel is the [[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]].  When code is typed into the REPL, or loaded
   from a file, it’s added to the environment and can be used by
   anything else inside it.

   The state of the environment can be saved to disk in a *Lisp
   image*, and restoed by executing that image from the shell.  When
   the image is saved, a different toplevel function can be specified.

   These are the building blocks for making executables.  Code is
   loaded into the environment, then an image is created from that
   state, with the toplevel set to the desired entry point.


* Version 1: Quick & Dirty

  With all that out of the way, it’s time to make a traditional
  "Hello, World" program.  This program will:

  1. Run from a shell.
  2. Use the first argument given to it as the name of the person or
     thing to greet.

  Starting from the ground up, the function to create the greeting:

  #+NAME: greet
  #+BEGIN_SRC lisp :tangle no :exports code
    (defun greet (whom)
      "Create a greeting message for WHOM."
      (format nil "Hello, ~A." whom))
  #+END_SRC

  #+RESULTS: greet
  : GREET

  Trying this in the REPL shows that it works:

  #+BEGIN_SRC lisp :tangle no :exports both :results value verbatim
  (greet "World")
  #+END_SRC

  #+RESULTS:
  : "Hello, World."


** The Toplevel Function

   To satisfy the first requirement, a toplevel function is needed —
   this will be evaluated when the image is restored, handling the
   command-line arguments and printing the greeting.

   I named the toplevel function =MAIN=, but it can be called
   anything.  Any function which accepts zero arguments can be used as
   a toplevel.

   #+NAME: main
   #+BEGIN_SRC lisp :exports code :results value verbatim
     (defun main ()
       "Greet someone, or something."
       (write-line (greet (car (uiop:command-line-arguments))))

       (uiop:quit))
   #+END_SRC

   #+RESULTS: main
   : MAIN

   There are two functions in here that may be new to you.

   Unlike other languages, the command-line arguments aren’t turned
   into arguments for the toplevel function; they’re returned from
   =UIOP:COMMAND-LINE-ARGUMENTS=.

   As one might expect, =UIOP:QUIT= function terminates the process.
   Both these functions come from ASDF, which is covered a bit later.


** Packages

   The next piece to get a handle on is packages.  This terminology is
   probably different than you’re used to; most other languages use
   "package" in the sense of "package manager," meaning a downloadable
   library and mechanism to install them.

   In Common Lisp, *a package is a namespace*.  Packages contains
   symbols.  The symbols can be defined in the package, like =MAIN=
   and =GREET=, or copied from other packages, like =DEFUN= and
   =FORMAT= (which both come from the =COMMON-LISP= package).

   For the Hello World program, it should be in its own package,
   called =HELLO=.

   Packages are created with [[http://www.lispworks.com/documentation/HyperSpec/Body/m_defpkg.htm][the =DEFPACKAGE= macro]], which takes a
   symbol naming the package:

   #+NAME: packages-bare
   #+BEGIN_SRC lisp :tangle no :exports code
     (defpackage :hello)
   #+END_SRC

   In Lisp, newly-created packages are /completely empty/, and don’t
   even include core language functionality like =DEFUN=.  Those
   symbols can still be referred to by qualifying them with the
   package name, but in most cases, it’s desirable to use them
   directly.  The =(:use …)= form of =DEFPACKAGE= copies symbols into
   the package being defined:

   #+BEGIN_SRC lisp :tangle no :exports code
     (defpackage :hello
       (:use :common-lisp))
   #+END_SRC

   If you hypothetically wanted to refer to more packages, their
   symbols would need to be added to that list:

   #+BEGIN_SRC lisp
     (defpackage :hello
       (:use :common-lisp :foo :bar))
   #+END_SRC

   Note that loading and using a package *are completely separate
   operations*.  While many languages have an =import= mechanism which
   both loads /and/ refers, Lisp doesn’t work this way; =:foo= and
   =:bar= must have been loaded already.

   The last thing to cover is exported symbols.  When a symbol is
   exported, it may be referred to by other packages; the set of
   exported symbols comprises the public API of a package.
   Non-exported symbols are only usable within the same package.

   Many languages specify visibility symbol-by-symbol, when they’re
   defined.  Lisp includes the list of symbols a package exports when
   the /package/ is defined, using the =(:export …)= form:

v   #+NAME: packages
   #+BEGIN_SRC lisp :tangle no :exports code
     (defpackage :hello
       (:use :common-lisp)
       (:export :greet :main))
   #+END_SRC

   #+RESULTS: packages
   : #<PACKAGE "HELLO">

   *Packages must be defined before they can be used*.  =DEFPACKAGE= establishes
   a forward declaration for the package, but doesn’t make it active.
   Since symbols are implicitly defined in the active package, =HELLO=
   needs to be made active:

   #+NAME: in-package-hello
   #+BEGIN_SRC lisp :tangle no :exports code
     (in-package :hello)
   #+END_SRC

   You may note that I’ve written the name of the package as =HELLO=
   (which it is), but it’s in the code as =:hello=.  For a deeper
   explanation on why this is the case, I recommend [[http://www.gigamonkeys.com/book/programming-in-the-large-packages-and-symbols.html][the chapter on
   Packages and Symbols]] from [[http://www.gigamonkeys.com/book/][Programming in the Large]].  In the mean
   time, you’ll just have to trust that it’s right and I know what I’m
   doing[fn:1].


** Tying it All Together

   The complete source for Hello World now looks like this:

   #+NAME: hello
   #+BEGIN_SRC lisp :tangle v1/hello.lisp :mkdirp yes :noweb yes :exports code
     <<packages>>

     <<in-package-hello>>

     <<greet>>

     <<main>>
   #+END_SRC

   #+RESULTS: hello
   : MAIN


** Building an Image

   Because the Common Lisp toolchain exists inside the Lisp
   environment, build scripts for Common Lisp project are written in,
   you guessed it, Lisp.

   The first thing to do is load the source of the program, in
   =hello.lisp=:

   #+NAME: load-hello
   #+BEGIN_SRC lisp :tangle no :exports code
     (load "hello.lisp")
   #+END_SRC

   Then, tell Lisp to dump the image into an executable, which will
   call =MAIN= when invoked:

   #+NAME: make-executable
   #+BEGIN_SRC lisp :tangle no :exports code
     (sb-ext:save-lisp-and-die "hello"
      :toplevel 'hello:main
      :executable t)
   #+END_SRC

   The precise mechanism to do this is dependent on which
   implementation is used, because the Common Lisp standard doesn’t
   cover it.  I’m using SBCL for these examples, and =SB-EXT= is a
   package it provides which has nonstandard extensions.

   The call to =SAVE-LISP-AND-DIE= *could* be put at the end of
   =hello.lisp= for this example, but it’s is a poor separation of
   concerns for anything more complex than one-off scripts[fn:2].  Its
   rightful place is =build.lisp=.

   The complete build script is then:

   #+NAME: build
   #+BEGIN_SRC lisp :tangle v1/build.lisp :exports code
     <<load-hello>>

     <<make-executable>>
   #+END_SRC

   Executing the build script with =sbcl(1)= will produce the binary:

   #+NAME: build
   #+BEGIN_SRC shell :dir v1 :results value verbatim :exports both
     sbcl --non-interactive --load build.lisp
   #+END_SRC

   #+RESULTS: build
   #+begin_example
   This is SBCL 1.3.14.debian, an implementation of ANSI Common Lisp.
   More information about SBCL is available at <http://www.sbcl.org/>.

   SBCL is free software, provided as is, with absolutely no warranty.
   It is mostly in the public domain; some portions are provided under
   BSD-style licenses.  See the CREDITS and COPYING files in the
   distribution for more information.
   [undoing binding stack and other enclosing state... done]
   [defragmenting immobile space... done]
   [saving current Lisp image into hello:
   writing 4800 bytes from the read-only space at 0x20000000
   writing 3216 bytes from the static space at 0x20100000
   writing 1179648 bytes from the immobile space at 0x20300000
   writing 13720752 bytes from the immobile space at 0x21b00000
   writing 37027840 bytes from the dynamic space at 0x1000000000
   done]
   #+end_example

   Running it shows the message:

   #+NAME: run-hello-world
   #+BEGIN_SRC shell :dir v1 :exports both :results value verbatim
     ./hello World
   #+END_SRC

   #+RESULTS: run-hello-world
   : Hello, World.

   Passing in the name of the current user also works:

   #+BEGIN_SRC shell :dir v1 :exports both :results value verbatim
     ./hello $(whoami)
   #+END_SRC

   #+RESULTS:
   : "Hello, ieure."

   Now that the program works, and you hopefully understand why and
   how, it’s time to tear it down and rebuild it a few times.


* Version 2: Package Structure

  Having all the code in one file is fine for a toy, but larger
  programs benefit from more organization.  If the core functionality
  is split from the CLI, other projects (or other parts of the same
  project) can reuse the greeting function without the CLI code.

  Also, Lisp packages can span files, so it’s not good practice to put
  the package definition in one of the /N/ files that represent its
  contents.

  What this should look like is:

  - =build.lisp=
  - =packages.lisp=
    - =src/=
      - =greet.lisp=
      - =main.lisp=

  The organization is different, but the contents of the files are
  almost exactly the same.

  The package definition is identical to v1, but moved into =packages.lisp=:

  #+BEGIN_SRC lisp :tangle v2/packages.lisp :noweb yes :export none
    <<packages>>
  #+END_SRC

  The greeting code is moved to =src/greet.lisp=.  It’s identical,
  except it has to declare the package it belongs to.

  #+NAME: v2-greet
  #+BEGIN_SRC lisp :tangle v2/src/greet.lisp :mkdirp yes :noweb yes
    <<in-package-hello>>

    ;; Unchanged from v1
    <<greet>>
  #+END_SRC

  The CLI code moves to =src/main.lisp=, and also declares what
  package it’s in:

  #+NAME: v2-main
  #+BEGIN_SRC lisp :tangle v2/src/main.lisp :noweb yes
    <<in-package-hello>>

    ;; Unchanged from v1
    <<main>>
  #+END_SRC

  The =build.lisp= script needs to load the new pieces in the correct
  order.  Since packages must be defined before they’re used,
  =packages.lisp= needs to be loaded before either of the files in
  =src/=; since =MAIN= calls =GREET=, the file containing =GREET= must
  be loaded before the one with =MAIN=:

  #+BEGIN_SRC lisp :tangle v2/build.lisp :mkdirp yes
    (load "packages.lisp")                  ; Load package definition
    (load "src/greet.lisp")                 ; Load the core
    (load "src/main.lisp")                  ; Load the toplevel

    ;; Unchanged from v1
    <<make-executable>>
  #+END_SRC

  Building and running works the same way:

  #+BEGIN_SRC shell :dir v2 :results value verbatim :export both
    sbcl --non-interactive --load build.lisp
    ./hello World
  #+END_SRC

  #+RESULTS:
  #+begin_example
  This is SBCL 1.3.14.debian, an implementation of ANSI Common Lisp.
  More information about SBCL is available at <http://www.sbcl.org/>.

  SBCL is free software, provided as is, with absolutely no warranty.
  It is mostly in the public domain; some portions are provided under
  BSD-style licenses.  See the CREDITS and COPYING files in the
  distribution for more information.
  [undoing binding stack and other enclosing state... done]
  [defragmenting immobile space... done]
  [saving current Lisp image into hello:
  writing 4800 bytes from the read-only space at 0x20000000
  writing 3216 bytes from the static space at 0x20100000
  writing 1179648 bytes from the immobile space at 0x20300000
  writing 13720752 bytes from the immobile space at 0x21b00000
  writing 37027840 bytes from the dynamic space at 0x1000000000
  done]
  Hello, World.
  #+end_example


* Version 3: Systems

  The next yak in the recursive shave is *systems*.  Packages [[https://www.cs.cmu.edu/Groups/AI/util/html/cltl/clm/node111.html#XPACK][are part
  of the Lisp language specification]], but systems are not; they’re
  provided by a library.  The dominant systems library at the time of
  writing is [[https://common-lisp.net/project/asdf/][ASDF]], which means "Another System Definition Facility."
  ASDF is widespread enough that it’s bundled with SBCL.

  Systems and packages are orthogonal, but since they both deal with
  some of the same parts of the project, it can get confusing.

  A package is *a way of organizing the symbols of a project inside
  the Lisp environment*.  Lisp doesn’t have a convention for
  determining what package things belong to based on the path or
  filename.  One package can be split across multiple files, or one
  file can contain multiple packages.  *Packages are not atomic*.
  It’s possible to load a subset of the files in a package.  All of
  this means the list of files loaded into the Lisp environment, and
  their order, is significant.

  A system is *a description of /how/ to load /part/ of a project into
  the environment*.  A system can load multiple packages, or it can
  load different parts of one package.  Systems encapsulate the list
  and order of files needed to produce a usable package.

  Further complicating things, *one project can have multiple
  systems*.  A system is a view into /part/ of a project, and
  different code may need different pieces.  For example, test code
  will need the test library loaded, or may need to set state before
  loading the code to be tested, or may need to change values inside
  the package containing it.  Having a separate system for tests
  allows these different usecases to be supported gracefully.


** Defining the System

   Systems are defined in an =.asd= file, using the =DEFSYSTEM= form.
   For the Hello World project, two systems are needed: one for the
   core, and one for the CLI.

   #+BEGIN_SRC lisp :exports code
     (defsystem :hello)
   #+END_SRC

   There are multiple strategies for loading code, but the easiest is
   to load components in the order they appear in the system
   definition:

   #+BEGIN_SRC lisp :exports code
     (defsystem :hello
       :serial t)
   #+END_SRC

   Then, the components need to be specified.  These are the files and
   directories the make up the system:

   #+BEGIN_SRC lisp :exports code
     (defsystem :hello
       :serial t
       :components ((:file "packages")
                    (:module "src"
                             :components ((:file "greet")))))

   #+END_SRC

   Then a secondary system for the binary.  The only new thing is
   =:depends-on=, which indicates that this system relies on the
   previous.

   #+NAME: defsystem-main
   #+BEGIN_SRC lisp
     (defsystem :hello/bin
       :depends-on (:hello)      ; This system needs the core HELLO system…
       :components ((:module :src
                     :components ((:file "main"))))) ; …and includes one
                                                     ; additional file.
   #+END_SRC


   The whole thing should look like:

   #+BEGIN_SRC lisp :tangle v3/hello.asd :noweb yes :mkdirp yes
     <<defsystem-hello>>

     <<defsystem-main>>
   #+END_SRC


   Since the system defines the files and load order, the build script
   can lean on ASDF instad of calls to =LOAD= now:

   #+NAME: build-v3
   #+BEGIN_SRC lisp :tangle v3/build.lisp
     (asdf:load-system :hello/bin)

     (sb-ext:save-lisp-and-die "hello"
      :toplevel 'hello:main
      :executable t)
   #+END_SRC

   ASDF needs to be told where to find the system definition, and all
   others it should be able to load.  This is [[https://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems][a complex topic]], but the
   simplest approach is:

   1. Use Quicklisp.
   2. Make a symlink from [[http://blog.quicklisp.org/2018/01/the-quicklisp-local-projects-mechanism.html][Quicklisp’s =local-projects=]] directory, named
      after the project, which points to the source tree.

   This is easily the grossest thing about this entire setup.

   #+BEGIN_SRC shell :exports both
     rm ~/quicklisp/local-projects/{hello,system-index.txt}
     ln -sf $PWD/v3 ~/quicklisp/local-projects/hello
   #+END_SRC

   #+RESULTS:

   The rest of the source is unchanged from v2.

   #+BEGIN_SRC lisp :tangle v3/packages.lisp :noweb yes :export no
     <<packages>>
   #+END_SRC

   #+BEGIN_SRC lisp :tangle v3/src/greet.lisp :noweb yes :mkdirp yes :export no
     <<v2-greet>>
   #+END_SRC

   #+BEGIN_SRC lisp :tangle v3/src/main.lisp :noweb yes :export no
     <<v2-main>>
   #+END_SRC

   Running works the same way:

   #+BEGIN_SRC shell :dir v3 :results value verbatim :export both
     sbcl --non-interactive --load build.lisp
     ./hello World
   #+END_SRC

   #+RESULTS:
   #+begin_example
   This is SBCL 1.3.14.debian, an implementation of ANSI Common Lisp.
   More information about SBCL is available at <http://www.sbcl.org/>.

   SBCL is free software, provided as is, with absolutely no warranty.
   It is mostly in the public domain; some portions are provided under
   BSD-style licenses.  See the CREDITS and COPYING files in the
   distribution for more information.
   ; compiling file "/home/ieure/Dropbox/Projects/cl/lh/v3/packages.lisp" (written 03 SEP 2018 03:56:31 PM):
   ; compiling (DEFPACKAGE :HELLO ...)

   ; /home/ieure/.cache/common-lisp/sbcl-1.3.14.debian-linux-x64/home/ieure/Dropbox/Projects/cl/lh/v3/packages-TMP.fasl written
   ; compilation finished in 0:00:00.001
   ; compiling file "/home/ieure/Dropbox/Projects/cl/lh/v3/src/greet.lisp" (written 03 SEP 2018 03:56:31 PM):
   ; compiling (IN-PACKAGE :HELLO)
   ; compiling (DEFUN GREET ...)

   ; /home/ieure/.cache/common-lisp/sbcl-1.3.14.debian-linux-x64/home/ieure/Dropbox/Projects/cl/lh/v3/src/greet-TMP.fasl written
   ; compilation finished in 0:00:00.002
   ; compiling file "/home/ieure/Dropbox/Projects/cl/lh/v3/src/main.lisp" (written 03 SEP 2018 03:56:31 PM):
   ; compiling (IN-PACKAGE :HELLO)
   ; compiling (DEFUN MAIN ...)

   ; /home/ieure/.cache/common-lisp/sbcl-1.3.14.debian-linux-x64/home/ieure/Dropbox/Projects/cl/lh/v3/src/main-TMP.fasl written
   ; compilation finished in 0:00:00.001
   [undoing binding stack and other enclosing state... done]
   [defragmenting immobile space... done]
   [saving current Lisp image into hello:
   writing 4800 bytes from the read-only space at 0x20000000
   writing 3216 bytes from the static space at 0x20100000
   writing 1187840 bytes from the immobile space at 0x20300000
   writing 13721392 bytes from the immobile space at 0x21b00000
   writing 37093376 bytes from the dynamic space at 0x1000000000
   done]
   Hello, World.
   #+end_example


* V4: Using Libraries

  The final step is to replace UIOP’s basic program arguments with a
  more full-featured library, [[https://github.com/libre-man/unix-opts][unix-opts.]]

  Common Lisp libraries are installed via Quicklisp, and loaded with
  ASDF.  As with other Common Lisp tasks, actually installing the
  library is done from the REPL.


** Quicklisp

   Quicklisp is not a package manager like other languages have.
   There’s no project-specific setup, like with virtualenv or rbenv.
   There’s no [[https://res.cloudinary.com/practicaldev/image/fetch/s--asKSgsVB--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/9i6bs4g6cx05jeagfhum.png][=node_modules=]].

   Quicklisp is more of a caching mechanism than a package manager.
   Similar to Maven’s =~/.m2=, a single copy of the code is stored in
   =~/.quicklisp=.  ASDF looks there when asked to load systems into a
   Lisp environment.

   As with other tooling, the primary interface for Quicklisp is the
   Lisp environment.


** Installing unix-opts

   The [[https://www.quicklisp.org/beta/][Quicklisp documentation]] discusses this, but I’m going to cover
   the essentials.

   Quicklisp has =ql:system-apropos=, which searches available
   libraries:

   #+BEGIN_SRC lisp :results value verbatim :export both
     (ql:system-apropos "unix")
   #+END_SRC

   #+RESULTS:

   Installing is done with =ql:quickload=.  This downloads the library
   (if necessary) and loads it:

   #+BEGIN_SRC lisp  :results value verbatim :export both
     (ql:quickload "unix-opts")
   #+END_SRC

   #+RESULTS:
   : ("unix-opts")


** Defining the Systems

   The only change to the system definitions is adding =:unix-opts= to
   the =:depends-on= form.  *Note that this refers to the /system/,
   not the package*.  Systems /provide/ packages, and /depend on/
   other systems.

   #+BEGIN_SRC lisp :tangle v4/hello.asd :noweb yes :export no
     <<defsystem-hello>>

     (defsystem :hello/bin
         :depends-on (:hello :unix-opts)       ; unix-opts dep added here
         :components ((:module :src
                               :components ((:file "main")))))
   #+END_SRC


** The New =MAIN=

   With the =:unix-opts= system loaded, the =:unix-opts= package is
   available for =MAIN= to use:

   #+BEGIN_SRC lisp :tangle v4/src/main.lisp
     (in-package :hello)

     (unix-opts:define-opts
       (:name :help
        :description "Print this help text"
        :short #\h
        :long "help"))

     (defun main ()
       "Greet someone, or something."
       (multiple-value-bind (options free-args)
           (unix-opts:get-opts)
         (if (or (getf options :help) (/= (length free-args) 1))
             (unix-opts:describe
              :prefix "A Hello World program."
              :args "WHOM")
             (write-line (greet (car free-args)))))

       (uiop:quit))
   #+END_SRC


   Nothing needs to change in any of the other files.

   #+BEGIN_SRC lisp :tangle v4/packages.lisp :noweb yes :export no
     <<packages>>
   #+END_SRC

  #+BEGIN_SRC lisp :tangle v4/build.lisp :noweb yes :mkdirp yes :export no
    <<build-v3>>
  #+END_SRC

   #+BEGIN_SRC lisp :tangle v4/src/greet.lisp :mkdirp yes :noweb yes :export no
   <<v2-greet>>
   #+END_SRC

   Before this can work, the Quicklisp =local-projects= symlink needs
   to be updated to point here instead of to the old version:

   #+BEGIN_SRC shell :export code :exports both
     rm ~/quicklisp/local-projects/{hello,system-index.txt}
     ln -sf $PWD/v4 ~/quicklisp/local-projects/hello
   #+END_SRC

   #+RESULTS:

   ... And the ASDF registry cleared:

   #+BEGIN_SRC lisp :export code
     (asdf:clear-source-registry)
   #+END_SRC

   After building (using the same commands as previously), the new
   options parser is working:

   #+BEGIN_SRC shell :dir v4
     sbcl --non-interactive --load build.lisp
   #+END_SRC

   #+BEGIN_SRC shell :dir v4 :results value verbatim :export both
     ./hello
   #+END_SRC

   #+RESULTS:
   : A Hello World program.
   :
   : Available options:
   :   -h, --help               Print this help text
   :

   #+BEGIN_SRC shell :dir v4 :results value verbatim :export both
     ./hello $(whoami)
   #+END_SRC

   #+RESULTS:
   : Hello, ieure.


* Conclusion

  At over four thousand words, this piece has been *a lot more* than I
  set out to write.  The process of learning, organizing, and refining
  my own understanding has been wonderful.  I hope you’ve been able to
  take away some of that, and will go forth with useful new tools.


* Further reading

  - [[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]]
  - [[https://www.cliki.net/CL-Launch][CL-Launch]] is a wrapper to ease running CL from the shell.  It can
    produce binaries, but is more suited to simple one-file programs.

* Footnotes

[fn:1] I have absolutely no idea what I’m doing.

[fn:2] If =SAVE-LISP-AND-DIE= was in =hello.lisp=, and that file was
loaded into any Lisp environment, it would immediately terminate,
which is unacceptably antisocial behavior.
